#' prepare benchmark data
#' @export
#' @param data analysis results
ms_bench_preprocess <- function(data) {
  tmp <- data %>%
    ungroup() %>%
    mutate(species  = case_when(
      grepl("HUMAN", protein_Id) ~ "HUMAN",
      grepl("ECOLI", protein_Id) ~ "ECOLI",
      TRUE ~ "OTHER"
    ))
  res <- tmp %>% dplyr::filter(!species == "OTHER")
  res <- res %>% mutate(TP = (species == "ECOLI"))
  return(list(data = res , table = table(tmp$species)))
}


# adds FDR, TPR and FDP to data.
# @param data
# @param TP_col column name of TP (TRUE, FALSE)
# @param arrangeby - by which column to sort.
# @param desc  descending or ascending.
# FDP - false discovery proportion (Q in Benjamini Hochberg table)
# FPR - false positive rate
# TPR - true positive rate
# TP_hits - true positives
#
.ms_bench_add_FPRTPR <- function(data,
                                 TP_col = "TP",
                                 arrangeby = "estimate",
                                 desc = TRUE) {
  #data <- est

  data <- if (!desc) {
    data %>% arrange(!!sym(arrangeby))
  } else{
    data %>% arrange(desc(!!sym(arrangeby)))
  }
  data <- data %>% select(scorecol = !!sym(arrangeby) , !!sym(TP_col))
  data$what <- arrangeby
  data$F_ <- sum(!data$TP)
  data$T_ <- sum(data$TP)

  data <- na.omit(data)
  data <- data %>% mutate(
    R = 1:n()
    , FDP = cummean(!TP)
    , TP_hits = cumsum(TP)
    , FN_hits = T_ - TP_hits
    , FP_hits = cumsum(!TP)
    , TN_hits = F_ - FP_hits
    , FPR = FP_hits / F_
    , TPR  = TP_hits / T_
    , ACC = (TP_hits + TN_hits) / (T_ + F_)
  ) %>% ungroup
  return(data)
}


#' computes auc and pauc given output from ms_bench_add_FPRTPR
#' using trapez rule
#' @export
#' @param FPR array of FPR
#' @param TPR array of corresponding TPR
#' @param fpr_threshold default = 1
#'
ms_bench_auc <- function(FPR, TPR, fpr_threshold = 1) {
  # make sure that sorted.
  oFPR <- order(FPR)
  FPR <- FPR[oFPR]
  TPR <- TPR[oFPR]

  idx <- FPR < fpr_threshold
  TPR <- TPR[idx]
  FPR <- FPR[idx]
  #integrate
  res <- 1 / 2 * sum(diff(FPR) * (head(TPR,-1) + tail(TPR,-1)))
  return(res / fpr_threshold * 100)
}


# scale_probabilities
# @param toscale columns to scale
# @param estimate fold change column
.scale_probabilities <-
  function(est ,toscale , estimate = "estimate") {
    addScaledP <- function(data , estimate , scale) {
      scaled.p = paste0("scaled.", scale)
      data <-
        data %>% dplyr::mutate(!!scaled.p := ifelse(!!sym(estimate) > 0,
                                                    1 - !!sym(scale) , !!sym(scale) - 1))
      return(data)
    }

    for (scale in toscale) {
      message(scale)
      est <- addScaledP(est, estimate = estimate , scale = scale)
    }
    return(est)
  }


# do_confusion
do_confusion <-
  function(data,
           arrangeby = list(list(sc = "estimate", desc = TRUE),
                            list(sc = "statistic", desc = TRUE),
                            list(sc = "scaled.p" , desc = TRUE),
                            list(sc = "scaled.moderated.p", desc = TRUE))) {
    # TODO add to LFQService
    est <- data %>% dplyr::select_at(c("TP",
                                       purrr::map_chr(arrangeby, "sc")))
    res <- list()
    for (arrange in arrangeby) {
      score <- arrange$sc
      res[[score]] <-
        .ms_bench_add_FPRTPR(est,
                             TP_col = "TP",
                             arrangeby = score,
                             desc = arrange$desc)
    }
    all <- bind_rows(res)
    return(all)
  }

# do_confusion for each contrast
do_confusion_c <- function(
  data,
  contrast = "contrast",
  arrangeby = list(list(sc = "p.value.adjusted", desc = FALSE),
                   list(sc = "moderated.p.value.adjusted", desc = FALSE))) {
  txx <- data %>% group_by_at(contrast) %>% nest()
  txx <- txx %>% mutate(out  = map(data,
                                   do_confusion,
                                   arrangeby = arrangeby))
  xx <- txx  %>% select_at(c(contrast, "out")) %>%
    unnest("out") %>%
    ungroup()

  # computes FDR FDP for all contrasts
  xy <- do_confusion(data, arrangeby = arrangeby)
  xy <- xy %>% dplyr::mutate(!!contrast := "all")
  #xy <- tibble::add_column(data, contrast = "all", .before = 1)
  xx <- dplyr::bind_rows(xy, xx)
  return(xx)
}


# Visualizes data frame with columns FPR, TPR, FDP
.plot_FDR_summaries <-
  function(pStats, fpr_lim = 0.2) {

    p1 <-
      ggplot(pStats , aes(x = FPR, y = TPR, color = what)) +
      geom_path() +
      labs(tag = "A") +
      facet_wrap( ~contrast )

    p2 <-
      ggplot(pStats , aes(x = FPR, y = TPR, color = what)) +
      geom_path()  +
      labs(tag = "B") +
      xlim(0, xlim = fpr_lim) +
      facet_wrap( ~contrast )
    p3 <-
      ggplot(pStats , aes(x = FDP, y = TPR, color = what)) +
      geom_path()  +
      labs(tag = "C") + xlim(0, fpr_lim) +
      facet_wrap( ~contrast )

    rocp <-
      ggpubr::ggarrange(
        p1,
        p2,
        p3,
        nrow = 1,
        common.legend = TRUE,
        legend = "bottom"
      )
    rocp = rocp

  }

.partial_AUC_summary <- function(pStats, model_description = "mixed effects model"){
  summaryS <- pStats %>% dplyr::group_by(contrast, what) %>%
    dplyr::summarize(
      AUC = ms_bench_auc(FPR, TPR),
      pAUC_10 =  ms_bench_auc(FPR, TPR, 0.1),
      pAUC_20 = ms_bench_auc(FPR, TPR, 0.2)
    )

  ftable <- list(content = summaryS,
                 caption = paste0("AUC, and pAUC at 0.1 and 0.2 FPR for ", model_description), digits = 2)

  sumd <- reshape2::melt(summaryS)
  barp <- ggplot(sumd, aes(x = contrast , y = value, color = NULL , fill = what)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    facet_wrap(~ variable, scales = "free") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    coord_cartesian(ylim = c(floor(min(sumd$value) / 10) * 10, 100))

  res <- list(
    barp = barp,
    summaryS = summaryS,
    ftable = ftable)
}

# summarise_missing_contrasts
.summarise_missing_contrasts <- function(data,
                                         hierarchy = c("protein_Id"),
                                         what = "statistic") {
  xxA <- data %>%
    group_by_at(hierarchy) %>%
    summarize(n = n(), nr_na = sum(is.na(!!sym(what))))
  summary <- as.data.frame(table(xxA$nr_na))
  colnames(summary) <- c("nr_missing", paste(hierarchy, collapse = "_"))
  return(list(summary = summary, nr_na = xxA))
}

# plot score distributions by species
.plot_score_distribution <- function(data,
                                     score =list(list(score = "estimate",xlim = c(-1,2) ),
                                                 list(score = "statistic", xlim = c(-3,10) )),
                                     contrast = "contrast",
                                     species = "species" ,
                                     annot = "peptide level statistics density"){
  plots <- list()
  for (i in score) {
    xlim = i$xlim
    score = i$score
    plots[[score]] <- data %>% ggplot(aes(x = !!sym(score),
                                          y = !!sym(contrast),
                                          color = !!sym(species))) +
      ggridges::geom_density_ridges(alpha = 0.1) + xlim(xlim)
  }
  fig <- ggpubr::ggarrange(plotlist = plots,
                           nrow = 1,
                           common.legend = TRUE,
                           legend = "bottom")

  fig <- ggpubr::annotate_figure(fig, bottom = text_grob(annot, size = 10))
  return(fig)
}

# Benchmark ----
#' Benchmark R6 class
#'
#' @export
#' @examples
#' library(ggpubr)
#' ttd <- ms_bench_preprocess(LFQService::resXXmedpolishTSV)
#' medpol_benchmark <- make_benchmark(ttd$data,
#'                                    model_description = "med. polish and lm. density",
#'                                    model_name = "prot_med_lm"
#' )
#' medpol_benchmark$plot_score_distribution()
#'
#' ttd <- ms_bench_preprocess(LFQService::brmsBench)
#' head(ttd)
#' #Benchmark$debug("pAUC_summaries")
#'# Benchmark$undebug("get_FDRvsFDP")
#' #Benchmark$debug("get_confusion")
#' #Benchmark$undebug("do_confusion")
#' brms_benchmark <- make_benchmark(
#'   ttd$data,
#'   toscale =  c("p.value", "regulation.probability"),
#'   benchmark = list(list(sc = "estimate", desc = TRUE),
#'                    list(sc = "statistic", desc = TRUE),
#'                    list(sc = "scaled.p.value", desc = TRUE),
#'                    list(sc = "scaled.regulation.probability", desc = TRUE)
#'   ),
#'   FDRvsFDP =
#'     list(list(sc = "p.value.adjusted", desc = FALSE),
#'          list(sc = "regulation.probability.adjusted", desc = FALSE)),
#'   model_description = "protein level measurments, brms model",
#'   model_name = "prot_brms"
#' )
#' brms_benchmark$complete()
#' debug(LFQService:::do_confusion_c)
#' bb <- brms_benchmark$get_confusion()
#' dim(bb)
#' head(bb)
#'
Benchmark <-
  R6::R6Class(
    "Benchmark",
    public = list(
      #' @field .data data.frame
      #' @field is_complete todo
      #' @field contrast column name
      #' @field toscale which columns to scale
      #' @field benchmark todo
      #' @field model_description describe model
      #' @field model_name model description
      #' @field hierarchy todo
      #' @field smc summarize missing contrasts
      #' @field confusion todo
      #' @field species todo
      #' @field FDRvsFDP todo
      .data = NULL,
      is_complete = FALSE,
      contrast = "",
      toscale = c(""),
      benchmark = list(),
      model_description = "",
      model_name = "",
      hierarchy = "",
      smc = NULL,
      confusion = NULL,
      species = "",
      FDRvsFDP = NULL,
      #' @description
      #' create Benchmark
      #' @param data data.frame
      #' @param toscale columns ot scale
      #' @param benchmark columns to benchmark
      #' @param FDRvsFDP score for which to generate FDR vs FDP
      #' @param columns to create FPR vs FDP analysis for
      #' @param model_description describe model
      #' @param model_name model name
      #' @param contrast contrast
      #' @param species species (todo rename)
      #' @param hierarchy e.g. protein_Id
      initialize = function(data,
                            toscale = c("p.value", "moderated.p.value"),
                            benchmark = list(
                              list(sc = "estimate", desc = TRUE),
                              list(sc = "statistic", desc = TRUE),
                              list(sc = "scaled.p.value", desc = TRUE),
                              list(sc = "scaled.moderated.p.value", desc = TRUE)
                            ),
                            FDRvsFDP = list(list(sc = "p.value.adjusted", desc = FALSE),
                                            list(sc = "moderated.p.value.adjusted", desc = FALSE)),
                            model_description = "protein level measurments, linear model",
                            model_name = "medpolish_lm",
                            contrast = "contrast",
                            species = "species",
                            hierarchy = c("protein_Id") ) {
        self$.data <- data
        self$contrast <- contrast
        self$toscale <- toscale
        self$benchmark <- benchmark
        self$FDRvsFDP <- FDRvsFDP
        self$model_description <- model_description
        self$model_name <- model_name
        self$hierarchy <- hierarchy
        self$species <- species

        self$smc <- .summarise_missing_contrasts(self$.data, hierarchy = hierarchy)
        self$.data <- .scale_probabilities(self$.data, toscale = toscale)

      },
      #' @description
      #' get data
      #' @return data.frame
      data = function(){
        if (self$is_complete) {
          nr_na <- self$smc$nr_na %>% filter(n == n - nr_na)
          return(dplyr::inner_join(self$.data, nr_na, by = self$hierarchy))
        } else {
          return(self$.data)
        }
      },
      #' @description
      #' set or get complete
      #' @param value TRUE if data should be complete (no missing contrasts)
      #'
      complete = function(value){
        if (missing(value)) {
          return(self$is_complete);
        } else {
          self$is_complete = value
        }
      },
      #' @description
      #' get confusion data
      #' @param arrange todo
      get_confusion = function(arrange){
        if (missing(arrange)) {
          arrange = self$FDRvsFDP
        }
        confusion <- LFQService:::do_confusion_c(self$data(),
                                    contrast = self$contrast,
                                    arrangeby = arrange)
        confusion <- tibble::add_column(confusion , model_name = self$model_name, .before = self$contrast)
        return(confusion)
      },
      #' @description
      #' get FDR summaries
      get_FDR_summaries = function(){
        self$get_confusion(arrange = self$benchmark)
      },
      #' @description
      #' plot FDR summaries
      #' @param xlim limit x axis
      #' @return ggplot
      plot_FDR_summaries = function(xlim = 0.5){
        confusion <- self$get_FDR_summaries()
        vissum <- .plot_FDR_summaries(confusion,
                                      fpr_lim = xlim)
        return(vissum)
      },
      #' @description
      #' AUC summaries
      pAUC_summaries = function(){
        confusion <- self$get_FDR_summaries()
        pauc <- .partial_AUC_summary(
          confusion,
          model_description = paste0(ifelse(self$complete(), " (CC) " , " (NC) "), self$model_description))
        return(pauc)
      },
      #' @description
      #' FDR vs FDP data
      get_FDRvsFDP = function(){
        xx <- self$get_confusion(arrange = self$FDRvsFDP)
        return(xx)
      },
      #' @description
      #' plot FDR vs FDP data
      #' @return ggplot
      plot_FDRvsFDP = function(){
        xx <- self$get_FDRvsFDP()
        #xx$FDP <- xx$FDP/seq(1,max(xx$FDP), length = length(xx$FDP))
        p <- ggplot(xx, aes(x = scorecol, y = FDP, color = !!sym(self$contrast))) +
          geom_line() +
          geom_abline(slope = max(xx$FDP), col = 2) +
          facet_wrap(~what)
        return(p)
      },
      #' @description
      #' plot distributions of scores
      #' @param score the distribution of which scores to plot (list)
      #' @return ggplot
      plot_score_distribution = function(score =list(list(score = "estimate", xlim = c(-1,2) ),
                                                     list(score = "statistic", xlim = c(-3,10) ))){
        .plot_score_distribution(self$data(),
                                 score = score,
                                 contrast = self$contrast,
                                 species = self$species,
                                 annot = paste0("statistics density of ", self$model_description ) )
      },
      #' @description
      #' plot intensity vs scores
      #' @param score the distribution of which scores to plot (list)
      #' @return ggplot
      plot_scatter = function(score =list(list(score = "estimate", ylim = c(-1,2) ),
                                          list(score = "statistic", ylim = c(-3,10) ))){
        x <- self$data()

        x <- x %>% arrange(desc(!!sym(self$species)))
        plots <- list()

        for (i in score) {
          score <- i$score
          ylim <- i$ylim

          plots[[score]] <- x %>%
            ggplot(aes(x = (c1 + c2)/2, y = !!sym(score), color = !!sym(self$species) )) +
            geom_point(alpha = 0.2) +
            ggplot2::facet_wrap(as.formula(paste("~", self$contrast))) +
            ylim(ylim)
        }
        fig <- ggarrange(plotlist = plots,
                         nrow = 1,
                         common.legend = TRUE,
                         legend = "bottom")
        fig <- annotate_figure(fig, bottom = text_grob(self$model_typ , size = 10))
        return(fig)
      }

    ))


#' make Benchmark
#'
#' @export
#' @param prpr todo
#' @param contrast todo
#' @param toscale todo
#' @param benchmark todo
#' @param FDRvsFDP todo
#' @param model_description todo
#' @param model_name todo
#' @param hierarchy todo
#' @return Benchmark
make_benchmark <- function(prpr,
                           contrast = "contrast",
                           toscale = c("p.value", "moderated.p.value"),
                           benchmark = list(
                             list(sc = "estimate", desc = TRUE),
                             list(sc = "statistic", desc = TRUE),
                             list(sc = "scaled.p.value", desc = TRUE),
                             list(sc = "scaled.moderated.p.value", desc = TRUE)
                           ),
                           FDRvsFDP = list(list(sc = "p.value.adjusted", desc = FALSE),
                                           list(sc = "moderated.p.value.adjusted", desc = FALSE)),
                           model_description = "protein level measurments, linear model",
                           model_name = "prot_med_lm",
                           hierarchy = c("protein_Id")
) {
  res <- Benchmark$new(prpr,
                       contrast = "contrast",
                       toscale = toscale,
                       benchmark = benchmark,
                       FDRvsFDP = FDRvsFDP,
                       model_description = model_description,
                       model_name = model_name,
                       hierarchy = hierarchy)
  return(res)
}
